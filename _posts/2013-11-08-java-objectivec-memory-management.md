---
layout: post
title: Java与Objective-C的内存管理比较
description: "对比Java和Objective-C两种语言在内存管理上的异同"
tags: [Java, Objective-C, Memory management, Tech]
category: articles
---

内存管理即应用程序分配、释放内存的一个过程：在需要的时候分配，使用完了释放。一个好的应用应使用尽可能少的内存。正如[Apple的文档](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html)中指出：

> Application memory management is the process of allocating memory during your program’s runtime, using it, and freeing it when you are done with it. 

我本人对Java的内存管理比较熟悉一点，在学习过程中也会对这两种语言的内存管理方式进行一些对比。所以本文的目的就是试图列出两种语言内存管理方面的一些异同。


## 内存泄露
所谓内存泄露，即应用程序没有及时释放不再使用的内存。不再使用也分两种，一种是应用程序代码理论上已经无法访问到那块内存，例如出了作用域的变量。这种情况下在Java下不存在。另外一种是应用仍然可以访问到那块内存，只是对于应用而言，那块内存是“无用”的，只是因为编码错误导致仍然保留着对那块内存的“引用”。是的，内存管理看似是对于对象的管理，事实上却是对于“对象图”的管理。即从根对象开始，如果没有任何路径到达某个对象，那么该对象就是可以回收的。


## 手动管理 vs. 自动管理
所谓自动管理，就是说你只需要管理如何分配内存就可以了，至于回收内存你则无需操心。Java通过“垃圾回收”机制来释放无用的内存。其存在已久，到现在也比较成熟了。但是这不代表在Java中就不存在内存泄露——如前所述，如果你不小心保留着对某个对象的引用，那么即使它对于你的程序而言已经是“无用”的，虚拟机却无法回收。

对于iOS而言，Objective-C的自动内存管理出现的时间却不是很久（Mac之前也有垃圾回收）。Objective-C使用所谓的“引用计数”（Reference Counting）来管理内存。这跟我以前理解的C++中的所谓“智能指针”是一个概念。即如果某个对象对另外一个对象有引用，那么引用计数+1，如果解除引用，那么计数-1。当引用计数为0时，内存就会被回收。虽然不是很方便，但是只要你遵循[一定的原则](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmRules.html#//apple_ref/doc/uid/20000994-BAJHFBGH)，还是比每次分配（例如用new），然后释放（例如delete）容易管理。

Objective-C的自动内存管理其实是自动引用计数（Automatic Reference Counting）。相对于Java是在**运行时**回收垃圾不同，这个操作是在**编译时**完成的。两者最大的差别，是前者（运行时的垃圾收集器）可以识别并回收循环引用，但是相对而言速度较慢，这有时候会成为一个很大的问题[^1]。后者虽然无法回收**强**循环引用，但是可以通过把循环引用中的部分引用改成**弱引用**（后面将会讨论）来打破这个循环，从而实现回收。好处当然是速度快，因为不需要在运行时花费大量的时间来查找和回收垃圾。更多关于两者的比较，可以查看[这篇讨论](http://lists.apple.com/archives/objc-language/2011/Jun/msg00013.html)。

前面讨论的基本上都是强引用。所谓的弱引用，是指该引用不会增加引用计数（Objective-C）或者在垃圾回收中改被忽略（Java）。也就是说，如果对于一个对象只有弱引用，那么该对象就是可以被回收的。Java中默认是强引用，使用WeakReference可以实现弱引用。Objective-C的ARC默认也是强引用，但是也可以通过某些方式指定弱引用。

刚才说到内存泄露，是指没有及时释放需要释放的内存。那么过度释放会怎么样呢？比如对于一个引用计数已经为0的对象再次解除引用？其结果将是未定义的。即可能有时候看起来好像什么事情也没有，然后在某个重要的时刻程序奔溃。

自动内存管理是Apple官方推荐的内存管理方式，安全而且高效。所有新的项目都应该尽量采用自动内存管理，对于老的项目而言，Xcode提供了一些比较简单的迁移。而如果在内存自动管理的项目中使用内存手动管理的代码或者库应该怎么办？可以对这些文件添加特定的编译参数(*-fno-objc-arc*)即可，从而可以使两种代码共存。

因为自动内存管理应该是绝大多数项目应该采用的方式，这里对于手动管理不再进行深入的讨论。

## 能够使用的内存
在Java中，每个应用可以指定能够使用的最大堆（heap）内存。当超过这个限制，应用就会抛出OutOfMemoryError这个错误。对于iOS的应用，则没有这个限制。但是因为手机上的内存一般都比较有限，而且iOS后面的版本支持任务后台运行，所以内存不够用是常有的事。当内存不足时，系统就会向应用发出内存警告。如果应用这个时候可以及时响应并释放部分内存，如缓存，那么程序就有可能继续运行下去，否则就会被杀掉。但是至于什么时候会收到内存警告，什么时候被杀掉，在前台被杀还是后台被杀，官方似乎没有给出明确的说明。但是下面几条指导原则应该是有效的：

- 后台内存占用最多的应用会第一个被杀掉
- 使用尽可能少的内存，定时做内存泄露检查
- 前台的应用可以使用更多的内存
- 前台的应用在iPhone 5下大约在150M时被杀，4s大约是100M（非官方数据）。

## 关于虚拟内存
虚拟内存即操作系统为应用分配的，比实际物理内存更多的“逻辑内存”，一般存在于硬盘上。iOS虽然支持虚拟内存，但是从不会像桌面操作系统那样，把不活跃的应用放置在虚拟内存中，一般只是简单地杀掉。只有只读数据，例如代码，才会在需要时从内存中移除并从磁盘（disk）重新加载。这应该是出于性能的考虑，因为磁盘读取是非常缓慢的，尤其是频繁的内存与虚拟内存交换（disk trashing）。

## 未讨论
- 虚拟内存系统的实现细节，似乎对具体的应用帮助不大。但是[WWDC 2013 410](https://developer.apple.com/wwdc/videos/index.php?id=410)似乎对其进行了较长篇幅的描述，没怎么看懂。
- bridge cast

[^1]: 尤其是对于实时性要求较高的程序或者UI程序。比如之前我从事的一个UI项目，某些情况下垃圾回收时间竟然长达半分钟。这个可以通过使用不同的垃圾收集器和不同的运行时参数，如最大堆内存来缓解，但可惜的是，这个问题最后也没有确认完全解决
