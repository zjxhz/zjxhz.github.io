---
layout: post
title: 搭建基于Openfire的聊天服务器
description: Openfire学习和使用过程中的一些记录
category: articles
tags: [openfire,搭建,配置]
---
[Openfire](http://www.igniterealtime.org/projects/openfire/)是搭建聊天服务器不错的选择，对于XMPP协议的支持比较完整，项目也比较活跃。Openfire用Java语言开发，这对于大多数人来说是件好事，因为毕竟熟悉Java的人比较多。我在之前尝试过[ejabberd](http://www.ejabberd.im/)，好像也是个不错的项目，无奈其用“这个地球上为数不多的人使用的”Erlang语言开发，如果只是配置和简单使用问题倒是不大，但是如果要自己去实现一些功能，而你又不熟悉这种语言，所要花费的时间就会比较多。而时间对于创业团队而言，显得尤其重要。

## 定制开发
这里简单介绍对于一个典型的同时有Web客服端和iOS客户端的项目而言，需要做的一些定制开发。

### 身份验证
Web客户端的身份验证似乎不是一个问题。对于iOS客户端而言，一种办法是用app本身的用户名密码进行登录。然而如果使用了社交账号登录如微博，那么身份验证可能会是一个问题。

### 推送
因为我们后台用的是[Django](https://www.djangoproject.com/)，所以实际的推送是用[pyapns](https://github.com/samuraisam/pyapns)完成的。Openfire这边的工作是：

- 编写一个插件，监听离线消息存储的消息（包括聊天消息和系统通知）
- 从离线消息中获取发送者，内容，并计算离线消息的条数等进行推送

### 消息归档（archiving）
所谓消息归档，就是在服务器端存储用户消息。这个功能并没有在官方版本获得支持，这里有[一个第三方插件](http://maven.reucon.com/projects/public/archive/)，我们在此基础上做了一些定制。在服务器端存储消息有几个好处：

- Web客户端可以查看历史消息。iOS客户端可以把收到的消息存储到手机上，但是对于Web客户端而言却只能通过把消息存储到服务器上来实现。
- 多客户端同步。因为Openfire默认会把离线消息发送给第一个连接上的客户端，比如Web客户端，然后删除，这就导致如果另外一个客户端，比如iOS客户端，再次连接服务器之后就看不到历史消息。

### 未读消息
在使用了消息归档之后，我们就摒弃了离线消息（Offline message），因为其只能被一个客户端接收。所以需要加入消息的已读和未读的标识。一种可能的情形是，本来有n条未读消息，用户登录了web客户端，查看了所有未读消息，并退出。之后又新产生了m条未读消息，这个时候手机客户端的未读数就要显示为最新的m条。反过来也是一样。

## iOS客户端
iOS客户端可基于[XMPPFramework](https://github.com/robbiehanson/XMPPFramework)开发。

### 消息归档格式
消息根据发送者，接受者和时间，分成若干个会话。一个会话（conversation），可以是如A和B之间15分钟内的所有消息。

### 获取哪一段消息？
如果本地已经有历史数据，那么比较简单，从最后一条消息以后的时间开始获取即可，这个需要服务端archive插件的支持。如果本地没有历史消息，那么可以选择读取一定时间内的，比如两周内，或者只获取未读的部分。

这里有个问题是，需要保证手机端的时间和服务器端的时间设置一致。因为实时消息是没有ID信息的，被archive的时候也是如此。当你下次连接到服务器的时候，请求**本地最后一条消息**之后的消息，而本地的消息和服务器端的消息时间可能并不完全一致。例如对于**实时消息**，本地的消息时间是指**收到消息的时间**，这可能有一定的延时。或者因为本地时间和服务器端时间的差异，导致该消息可能略微早于服务器上的那条消息，这些都是可能存在的。所以以时间来唯一区别一条消息可能并不是十分靠谱——你可能会收到重复的消息，这也是我们开发过程中遇到的一个实际问题。后来用的一个比较简单的方法是：比较离线消息和本地的最后一条或者数条消息，看内容是否完全一致。如果是，则直接忽略。这样就解决了绝大多数情况下的问题，当然也不排除有的人连续快速发重复的消息，不过这种情况下即使部分重复消息丢失我们认为是可以接受的。

不确定例如QQ等IM是否基于XMPP开发，不过我发现最新的QQ版本似乎有重复消息的问题，不确定原因是否类似。

### 获取消息
客户端请求**某个时间点之后的所有消息**，服务端把这个时间点之后的所有**会话**发送给客户端。客户端根据接收到的会话向服务器端再次请求所有会话中的所有消息——通过查询某个会话里的最早的一条消息之后的所有消息。所以这里要注意的问题是，根据会话时间设置的长短，如果和某人的会话多于一个，那么便会有重复的消息。因为旧的会话之后的所有消息包含新会话的消息。所以需要把同一人的新会话给忽略掉。当然，这根据archive实现的不同而略有不同。如果服务端能返回只和那个会话相关的消息，客户端的实现还可以更简单一些。

### 分页
如果某个会话消息过多，那么分页获取是个好办法。Mac版的QQ似乎一直有这个问题，我发现对于群组消息，如果未读超过20条，那么下次连接上去最多只能读取20条。而iOS版的QQ就没有这个问题。感觉Mac版的QQ问题还比较多。


### 消息部分收取失败
前面提到的获取哪一段消息的时候，是根据本地最新的一条消息。然而这可能会成为问题。例如在收取会话的时候，加入有3段会话，X，Y，Z。由于会话是逐个收取的，如果Y收取的时候部分失败，那么下次再次收取的时候，Z会话中可能还有部分早于Y会话中最新消息的消息。这部分消息无法被收取。我的一个比较简单的解决办法是，当收取Z会话时，会把Z会话中最后一条消息的时间作为消息Z会话的收取时间点。

### Pubsub

Pubsub比较适合用来发送系统通知，比如我创建了某个活动，以后有人加入这个活动的时候我希望自己能够收到通知。对于后面加入的人也是一样，如果B是第二个加入的，那么当C作为第三个人加入的时候，B也希望得到通知。

#### 简单的流程

我创建一个活动，并为此创建一个名如/meal/meal_id/participants的node。我作为创建者自动成为subscriber。当有人，假定为B，参加了这个活动后，我向该node publish一条消息，告知了比如哪个用户加入了哪个活动。该用户subscribe这个node，这样以后有人加入的时候他也会收到通知。

需要注意的地方是，如果服务端是用openfire，那么B也会收到一条自己参加了这个活动的通知。这个是由于openfire默认会将最后一条消息发给新的subscriber。如果不想要这个特性，有两个办法：

- 创建node的时候 设置*pubsub#send_last_published_item*属性为**never**，或
- 修改openfire数据库的表ofPubsubDefaultConf，将对应的pubsub service的sendItemSubscribe改为0，应该要重启生效。不确定是否还有其它方式修改
- 对于已经创建了的node，可以将ofPubsubNode表中的sendItemSubscribe字段改为0
- 如果不希望使用Multiple Subscriptions，可以修改ofProperty表，将xmpp.pubsub.multiple-subscriptions 设置为false。禁用有几个好处，例如避免产生重复的通知，unsubscribe的时候，对于同一个jid，不再需要指定具体想unsubscribe哪一个。

参考：http://xmpp.org/extensions/xep-0060.html

## 参考

- [XMPP协议](http://xmpp.org/)
