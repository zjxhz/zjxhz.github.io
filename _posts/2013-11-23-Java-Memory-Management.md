---
layout: post
title: Java内存管理概述
description: 总结Java内存管理的一些知识
tags: [Java, Memory, Management, 内存，管理]
category: articles
---
Java使用基于垃圾收集的自动内存管理，即程序员并不需要关心对象在内存空间的分配和释放，这个过程由垃圾收集器完成。

## 垃圾收集器

### 主要特征
垃圾收集器的设计是一个复杂的工作，需要考虑的主要有以下几个方面

#### 安全和彻底
安全就是不释放尚被引用的内存，彻底即释放了所有未被引用的内存。否则，前者会导致程序奔溃，而后者导致内存泄露。对于需要手动管理内存的程序，这两种情形都比较难以避免，程序员要花大量的时间在这两件事情上面。从而导致能够花在真正需要的“功能”上的时间相对减少。

#### 效率
关于效率，要考虑的东西比较多，主要是以下几个方面。

- 吞吐率。即程序在垃圾收集上的花了多少时间，一般按照百分比来计算。因为一个程序更重要得是如何正确有效地实现用户想要的功能，而非*收集垃圾*。
- 停止时间。垃圾收集需要花时间，而且有时候需要把整个应用程序都停下来，这个活动才能进行。这对于实时性要求比较高的程序而言，可能是个问题。比如GUI程序，可能会造成界面不响应用户操作，即*假死*。
- 频繁度。如果虽然每次停止时间不长，但是却很频繁，也可能会成为问题。同样以GUI程序为例，虽然程序正确地响应了用户操作，但是时不时地会有卡顿现象，用户体验也很不好，即所谓的*很卡*。
- 内存占用。无疑，垃圾收集也需要占用内存。

#### 内存碎片
如硬盘会产生碎片一样，内存也会产生碎片。

#### 可扩展性
例如对于多线程程序，或者多核的系统，垃圾收集是否会成为一个瓶颈？

### 设计考量
正因为如上所述的问题，需要对如下方面进行考量

#### 串行还是并行？
在多核系统上，并行一般会比串行更快。但是这也导致了一些复杂性，以及可能的碎片。

#### 并发还是暂停？
如前所述，垃圾收集可能需要暂停整个程序。对于某些程序来讲，这难以接受。所以，垃圾收集也可以实现为并发执行，即并不需要暂停整个程序。虽然这带来了一点额外的开销（当然还有复杂度），时间和空间上的，但是一般可以接受。需要注意的是，所谓的并发垃圾收集器，有时候也需要短暂地暂停一下程序（例如做标记），虽然其大部分工作是并发的。

#### 整理碎片，还是不整理？
整理碎片需要时间，不整理，可能虽有额外的空间可用，但是无法容纳大的对象，从而造成空间的浪费。

## 分代收集
所谓分代，就是把内存分成几代，比如年轻代，老年代来管理。顾名思义，年轻代的内存用于存放刚创建的对象。如果这些对象在几次垃圾回收之后仍然存活，就会被移动到老年代。之所以如此划分，主要是因为大多数对象的生命周期是很短暂的：在他们被移动到老年代之前，就已经被回收了。一般年轻代比老年代的空间要小，垃圾回收也频繁得多。所以对于年轻代的垃圾收算法，主要看重速度；而对于老年代，则主要看重空间利用率。

对于某些比较大的对象，有可能会直接被分配到老年代，这是为了减少后面如果要移动而产生的代价。

## HotSpot虚拟机的垃圾收集器
我们知道，虚拟机有不同的实现。原来Sun公司提供的叫HotSpot，而Oracle提供的叫JRocket。Oracle收购了Sun之后，现在Java默认的虚拟机是哪一个？这我还真不清楚。

### 更多的“代”
不管怎么样，对于HotSpot而言，其内存被分成更多的代。比如除了年轻代和老年代之外，还有一**个永久代**，用于存放比如关于类、方法等元信息。年轻代也被分成更小的区域，例如其中一个叫伊甸园。但是基本的原理和前面所说的是一致的，这里不再做深入的介绍。

### 快速分配内存
在大部分情况下，内存中有大块连续的空闲空间。所以为对象分配内存只需要连续分配即可，速度也很快。但是对于多线程程序，对于使用同样的地址空间需要加锁同步访问，这在很大程度上降低了内存分配的效率。所以一种办法是为每个线程分配独立的空间地址，大家互不干扰，所以不必加锁。只有在空间不够的情况下，才有可能需要互斥访问。

### 收集器种类

#### 串行收集器（Serial Collector）
单线程的，并且在每次收集的时候需要暂停整个程序的执行。虽然看起来不尽如人意，但是对于单核或者小程序（使用内存小于64M）而言却足够了。

#### 并行收集器（Parallel Collector）
在多核的系统中，可以使用并行收集器。但是需要注意的是，该收集器在工作时仍然会暂停整个程序。

#### 并行且整理碎片之收集器（Parallel Compacting Collector）
与并行收集器类似，只是对于老年代的垃圾回收，会定时整理内存碎片，并且该过程会分成几个阶段进行，从而减少暂停程序程序的时间。这种方式会占用多个CPU大量的资源，可以通过限制线程数来减少对CPU的占用。

#### 并发收集器（Concurrent Mark-Sweep (CMS) Collector）
并发收集器试图尽量减少程序暂停时间，这对于大部分程序而言比提高吞吐率更有意义。另外，此收集器还会占用更多一点的内存。值得注意的是，对于老年代的垃圾收集，它并不是在老年代满了才开始收集，而是到了一定的百分比就开始。这对于减少程序暂停时间是有意义的。并发收集器使用多线程以利用多核优势，但是它并不进行内存碎片的整理，而通过另外一种比较巧妙的方式来避免空间浪费。

## 其它
这篇文章并不打算讨论垃圾收集器的工作原理，以及性能调优等内容。有兴趣请参考下面的原文链接

## 参考

- [Memory Management in the Java HotSpot Virtual Machine](http://www.oracle.com/technetwork/java/javase/memorymanagement-whitepaper-150215.pdf)
- [JRocket Memory Management](http://docs.oracle.com/cd/E13150_01/jrockit_jvm/jrockit/geninfo/diagnos/garbage_collect.html)
