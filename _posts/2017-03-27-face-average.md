---
layout: post
title: 平均脸 
description: 
category: articles
tags: 
---
不管是Face++的API，还是dlib，不仅能检测到人脸的位置，还能给出面部的「关键点」。所谓关键点，就是标明了面部轮廓，以及主要脸部器官的点。体会一下：

![landmarks](/images/landmarks.png)

这些点有什么用呢？对于美女识别的学习算法而言，也许是没什么用。但是对于人脸图像特效处理，比如「平均脸」，就很有用了。所谓平均脸，顾名思义，就是把每个人的脸平均一下。具体的做法就是，首先，我们知道，计算机显示的图片，是由一个个的点来组成的。每一个点，一般由三原色即红绿蓝（RGB）三色来表示。比如红色，就是红色取值255，其余两色取值0；而黄色则是红色和绿色各取255，蓝色为0；而洋红色则是红色和蓝色各255，绿色为0；白色即是三原色都是255；等等。这样，我们就可以表示大约1600多万种颜色。所谓平均，就是把两张图片的每个对应的点的颜色值加起来，再除以图片的数量。听起来似乎很简单。但是这里面有几个问题：

1. 图片大小可能不一样
2. 脸在图片中的位置不一样
3. 脸的大小会不一样
4. 五官的位置也会不一样

上一篇所说的算法，只解决了前面两个问题。如果你这个时候急着去计算平均脸，那么会得到大致如下的图像：

![naive average](/images/naive_average.png)

这是因为，脸部的图片只是大致对齐了。这个时候关键点就起作用了。我们要做的，是根据关键点，把整张图片切割成若干个三角形。简单来讲，就是比如鼻子在一个三角形，嘴巴在一个三角形，眼睛分别在两个三角形等等。这样，我们就可以根据不同脸部的三角形的一一对应关系来做平均，从而保证鼻子只和鼻子平均，嘴巴只和嘴巴平均，等等。

具体怎么划分呢？这就要使用到「德劳内」三角形了。这种划分的办法有一个特点，就是使得所有三角形中「最小的角」最大化。也就是说，尽量避免瘦长的三角形出现。有兴趣的可以去研究一下算法。不过，OpenCV的类库中已经提供了这个功能。什么？我还没介绍OpenCV？好吧，这是另外一个图形处理库（CV是计算机视觉的缩写），包含了超过2500多个高度优化的算法，已经有了超过1500万的下载量，非常强大。尤其难能可贵的是，文档也写得很好（当然不是告诉你某行代码出了十几个缺陷的那种好）。

如果你不是很关心细节，不妨还是来看一下分割的效果：

![delauney triangles excluding boundary points](/images/delauney0.png)

如果我们加入边上的8个点，那么切分效果如下：
![delauney triangles including boundary points](/images/delauney1.png)

包含边上的点，是为了对整张图片做一个平均，否则你得到的可只是一张脸，而不会有头发背景这些东西。

准备就绪，让我们看看效果如何：

![未排序的平均脸](/images/unordered_average.png)

WTF？可怜的领袖们。嘴巴倒是好像还在那里，其它的器官都错位了。难道是打开方式不对？确认了下打开方式，没错。

如果我们回顾下德劳内三角形的定义，可以知道，这种分割方式只是保证所有三角形中「最小角的最大化」。但是对于平面上不同的点，其给出的分割方法是不一样的——虽然，每个人的脸差别并不大。把每个三角形标上序号，用一个图，我们就可以看出来到底哪里不对了。

![delauney_indexes.png](/images/delauney_indexes.png)

这里需要点击大图查看。因为三角形太多，有的数字有点重叠。但是如果我们只看最上方的几个大三角形，就可以看到序号已经不一样了。牛头和马嘴做平均，得到之前那个的结果也就不奇怪了。解决的办法是，首先计算出某一张图的德劳内三角形分割法，并记住每个三角形各用了「关键点」中的哪些点。以后的每个图片都以此为基准，这样就可以保证不同的图中的「相同序号」的三角形大致对应的都是同一个地方了——虽然严格上来讲，这个时候只有第一张图才是德劳内三角分割。这样做了之后，得到下图：

![average_including_boundary_points.png](/images/average_including_boundary_points.png)

虽然边上看起来有点虚（后面我们会讲如何解决这个问题），但是至少脸部比一开始没有做「脸部对齐」的效果好多了。



